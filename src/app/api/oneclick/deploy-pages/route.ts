import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { unauthorizedError, validationError, serverError, apiError, notFoundError } from '@/lib/api/errors';
import { rateLimit } from '@/lib/rate-limit';
import { logAudit } from '@/lib/audit';
import { checkHomepageDeployQuota } from '@/lib/quota';
import { createRepo, pushFilesAtomically, deleteRepo, enableGitHubPagesWithActions, GitHubApiError } from '@/lib/github/api';
import { homepageTemplates } from '@/data/homepage-template-content';
import { decrypt } from '@/lib/crypto';
import { deployPagesRequestSchema } from '@/lib/validations/oneclick';

export async function POST(request: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return unauthorizedError();

  const { success } = rateLimit(`oneclick-deploy-pages:${user.id}`, 5, 60_000); // 5 per 1 min
  if (!success) return NextResponse.json({ error: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.' }, { status: 429 });

  const body = await request.json();
  const parsed = deployPagesRequestSchema.safeParse(body);
  if (!parsed.success) return validationError(parsed.error);

  const { template_id, site_name, github_service_account_id } = parsed.data;

  // 1. Quota check
  const quotaCheck = await checkHomepageDeployQuota(user.id);
  if (!quotaCheck.allowed) {
    return apiError(
      `무료 배포 한도에 도달했습니다 (${quotaCheck.current}/${quotaCheck.max}). Pro 플랜으로 업그레이드하세요.`,
      403
    );
  }

  // 2. Get template
  const { data: template } = await supabase
    .from('homepage_templates')
    .select('*')
    .eq('id', template_id)
    .eq('is_active', true)
    .single();

  if (!template) return notFoundError('템플릿');

  // 3. Get GitHub service account
  const { data: githubService } = await supabase
    .from('services')
    .select('id')
    .eq('slug', 'github')
    .single();

  if (!githubService) {
    return serverError('GitHub 서비스 설정을 찾을 수 없습니다');
  }

  let ghQuery = supabase
    .from('service_accounts')
    .select('id, project_id, encrypted_access_token, encrypted_refresh_token, token_expires_at, oauth_scopes, oauth_provider_user_id, oauth_metadata')
    .eq('user_id', user.id)
    .eq('service_id', githubService.id)
    .eq('connection_type', 'oauth')
    .eq('status', 'active');

  if (github_service_account_id) {
    ghQuery = ghQuery.eq('id', github_service_account_id);
  }

  const { data: ghAccount } = await ghQuery
    .order('project_id', { ascending: true, nullsFirst: true })
    .limit(1)
    .single();

  if (!ghAccount) {
    return apiError('GitHub 계정이 연결되어 있지 않습니다. 먼저 GitHub를 연결해주세요.', 404);
  }

  let githubToken: string;
  try {
    githubToken = decrypt(ghAccount.encrypted_access_token);
  } catch {
    return apiError('GitHub 토큰이 유효하지 않습니다. 다시 연결해주세요.', 401);
  }

  // 4. Create Linkmap project
  const { data: project, error: projectError } = await supabase
    .from('projects')
    .insert({
      user_id: user.id,
      name: site_name,
      description: `${template.name_ko} 템플릿으로 생성된 GitHub Pages 사이트`,
    })
    .select()
    .single();

  if (projectError) return serverError(projectError.message);

  // 4.5. Copy user-level service account to project
  let projectServiceAccountId = ghAccount.id;
  if (!ghAccount.project_id) {
    const { data: copiedAccount } = await supabase.from('service_accounts').insert({
      project_id: project.id,
      service_id: githubService.id,
      user_id: user.id,
      connection_type: 'oauth',
      encrypted_access_token: ghAccount.encrypted_access_token,
      encrypted_refresh_token: ghAccount.encrypted_refresh_token,
      token_expires_at: ghAccount.token_expires_at,
      oauth_scopes: ghAccount.oauth_scopes,
      oauth_provider_user_id: ghAccount.oauth_provider_user_id,
      oauth_metadata: ghAccount.oauth_metadata,
      status: 'active',
      last_verified_at: new Date().toISOString(),
    }).select('id').single();

    if (copiedAccount) {
      projectServiceAccountId = copiedAccount.id;
    }
  }

  // 5. Look up bundled template content
  const templateContent = homepageTemplates.find(t => t.slug === template.slug);
  if (!templateContent) {
    await supabase.from('projects').delete().eq('id', project.id);
    return apiError(`템플릿 번들을 찾을 수 없습니다 (${template.slug}). 관리자에게 문의하세요.`, 404);
  }

  // 5a. Create repo (auto_init: true to avoid 409 on empty repo Git Data APIs)
  let repoResult;
  try {
    repoResult = await createRepo(
      githubToken,
      site_name,
      `${template.name_ko} - Generated by Linkmap`,
      { auto_init: true }
    );
  } catch (err) {
    await supabase.from('projects').delete().eq('id', project.id);

    if (err instanceof GitHubApiError) {
      if (err.status === 422) {
        return apiError(`'${site_name}' 이름의 레포지토리가 이미 존재합니다. 다른 이름을 사용해주세요.`, 409);
      }
      if (err.status === 403) {
        return apiError('GitHub 권한이 부족합니다. GitHub 연결을 해제 후 다시 연결해주세요.', 403);
      }
      return apiError(`GitHub 레포지토리 생성 실패: ${err.message}`, 502);
    }
    return serverError('GitHub 레포지토리 생성 중 오류가 발생했습니다');
  }

  // 5b. Push all template files as a single atomic commit (with retry)
  const MAX_RETRIES = 2;
  let pushError: unknown = null;
  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      // Small delay to let GitHub finalize repo init (especially for auto_init repos)
      if (attempt === 0) await new Promise((r) => setTimeout(r, 1000));
      else await new Promise((r) => setTimeout(r, 2000 * attempt));

      await pushFilesAtomically(
        githubToken,
        repoResult.owner.login,
        repoResult.name,
        templateContent.files,
        'Initial commit from Linkmap'
      );
      pushError = null;
      break;
    } catch (err) {
      pushError = err;
      // Only retry on 409 (conflict/empty repo race) or 502 (transient gateway error)
      if (err instanceof GitHubApiError && (err.status === 409 || err.status === 502) && attempt < MAX_RETRIES) {
        continue;
      }
      break;
    }
  }

  if (pushError) {
    // Clean up: delete the created repo and project
    try {
      await deleteRepo(githubToken, repoResult.owner.login, repoResult.name);
    } catch { /* best effort cleanup */ }
    await supabase.from('projects').delete().eq('id', project.id);

    if (pushError instanceof GitHubApiError) {
      return apiError(`파일 업로드 실패: ${pushError.message}`, 502);
    }
    return serverError('템플릿 파일 업로드 중 오류가 발생했습니다');
  }

  // 6. Enable GitHub Pages (Actions-based workflow)
  let pagesStatus: 'enabling' | 'built' = 'enabling';
  const pagesUrl = `https://${repoResult.owner.login}.github.io/${repoResult.name}`;

  try {
    await enableGitHubPagesWithActions(
      githubToken,
      repoResult.owner.login,
      repoResult.name
    );
    pagesStatus = 'enabling';
  } catch (err) {
    if (err instanceof GitHubApiError && err.status === 409) {
      // Pages already enabled
      pagesStatus = 'enabling';
    } else {
      // Pages enablement failed - clean up repo and project
      try {
        await deleteRepo(githubToken, repoResult.owner.login, repoResult.name);
      } catch { /* best effort cleanup */ }
      await supabase.from('projects').delete().eq('id', project.id);

      const errMsg = err instanceof GitHubApiError ? err.message : 'GitHub Pages 활성화 실패';
      return apiError(`GitHub Pages 활성화 실패: ${errMsg}`, 502);
    }
  }

  // 7. Link repo to project
  await supabase.from('project_github_repos').insert({
    project_id: project.id,
    service_account_id: projectServiceAccountId,
    owner: repoResult.owner.login,
    repo_name: repoResult.name,
    repo_full_name: repoResult.full_name,
    default_branch: repoResult.default_branch,
    auto_sync_enabled: false,
  });

  // 8. Create homepage_deploys record
  const { data: deploy, error: deployError } = await supabase
    .from('homepage_deploys')
    .insert({
      user_id: user.id,
      project_id: project.id,
      template_id: template.id,
      site_name,
      forked_repo_full_name: repoResult.full_name,
      forked_repo_url: repoResult.html_url,
      fork_status: 'forked',
      deploy_status: 'building',
      deploy_method: 'github_pages',
      pages_url: pagesUrl,
      pages_status: pagesStatus,
    })
    .select()
    .single();

  if (deployError) return serverError(deployError.message);

  // 9. Add project_services (GitHub only, no Vercel)
  await supabase.from('project_services').insert({
    project_id: project.id,
    service_id: githubService.id,
  });

  // 10. Audit log
  await logAudit(user.id, {
    action: 'oneclick.deploy_pages',
    resourceType: 'homepage_deploy',
    resourceId: deploy.id,
    details: {
      template_slug: template.slug,
      site_name,
      repo: repoResult.full_name,
      pages_url: pagesUrl,
      project_id: project.id,
    },
  });

  return NextResponse.json(
    {
      deploy_id: deploy.id,
      project_id: project.id,
      repo_url: repoResult.html_url,
      pages_url: pagesUrl,
      pages_status: pagesStatus,
    },
    { status: 201 }
  );
}
